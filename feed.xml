<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="https://foxhole.nl/feed.xml" rel="self" type="application/atom+xml"/><link href="https://foxhole.nl/" rel="alternate" type="text/html" hreflang="en"/><updated>2024-08-01T11:57:30+00:00</updated><id>https://foxhole.nl/feed.xml</id><title type="html">Joost Voskuil Blog</title><subtitle>Just some thoughts and ideas. Nothing more. Thoughts are my own. </subtitle><entry><title type="html">What We Can Learn from SpaceX Regarding DevOps</title><link href="https://foxhole.nl/blog/2024/what-we-can-learn-from-spacex-regarding-devops/" rel="alternate" type="text/html" title="What We Can Learn from SpaceX Regarding DevOps"/><published>2024-03-01T23:36:10+00:00</published><updated>2024-03-01T23:36:10+00:00</updated><id>https://foxhole.nl/blog/2024/what-we-can-learn-from-spacex-regarding-devops</id><content type="html" xml:base="https://foxhole.nl/blog/2024/what-we-can-learn-from-spacex-regarding-devops/"><![CDATA[<blockquote> <p>This blogpost was writen for Delta-N and originally posted in Dutch on <a href="https://www.delta-n.nl">the Delta-N website</a></p> </blockquote> <p>A real revolution in space technology is happening right now. SpaceX, the company of Elon Musk, accounts for 80 percent of the total mass brought into space. This number will rapidly increase to 90 percent. Many people are critical of Elon Musk. For this blog, we need to look beyond his ego and focus on how the engineers on the ground are working. In my opinion, SpaceX’s success is due to their approach. Within DevOps, we can learn a lot from them. In this blog, I want to discuss the difference between NASA and SpaceX (both developing a new rocket) and what makes SpaceX so unique.</p> <h2 id="the-space-launch-system-sls-rocket-from-nasa">The Space Launch System (SLS) Rocket from NASA</h2> <p>NASA is currently developing the <a href="https://www.nasa.gov/exploration/systems/sls/index.html">Space Launch System (SLS) rocket</a>. This rocket is expected to bring humans back to the moon within a few years. Artemis is the successor to the Apollo program from the 1960s and 70s. The SLS rocket is an evolution of the Space Shuttle that last flew in 2011 and uses revised and optimized components from the Space Shuttle. NASA receives its budget from the United States treasury under strict conditions. The money must be spent on subcontractors active in certain states to guarantee jobs, involving significant lobbying between senators. This rocket is for single use; after launch, the components burn up in the atmosphere or fall into the ocean. Making and launching four rockets costs about $41 billion. Because it involves public money, no mistakes are allowed, as this would result in negative publicity and reputational damage. The approach is waterfall, where the entire system is designed, built, inspected, tested, tested again, and tested once more. Due to the subcontractors, a lot of time is spent aligning the designs. This all feels safe, and it is necessary because people will soon be flying in the Orion capsule of the SLS rocket to the moon. NASA chooses 100% certainty: ‘failure is not an option.’ From the first launch, it must go perfectly.</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/sls-480.webp 480w,/assets/img/sls-800.webp 800w,/assets/img/sls-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/sls.jpg" class="img-fluid rounded z-depth-0" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <h2 id="the-starship-rocket-from-spacex">The Starship Rocket from SpaceX</h2> <p>SpaceX is currently developing Starship. <a href="https://www.spacex.com/vehicles/starship/">Starship</a> is the largest, heaviest, and most powerful rocket ever made. There is a significant difference with NASA’s SLS rocket: Starship will be fully and quickly reusable, like an airplane. Launch, land, refuel, and relaunch. This significantly reduces costs for bringing mass into space.</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/starship-480.webp 480w,/assets/img/starship-800.webp 800w,/assets/img/starship-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/starship.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <p>At the time of writing, the second test rocket is ready for launch. This will undoubtedly be accompanied by a large explosion, or as SpaceX calls it, a ‘Rapid Unscheduled Disassembly.’ Our media will negatively highlight this as a rocket explosion, but for SpaceX, it is not a failure. For SpaceX, it is about collecting data and learning—learning a lot and learning quickly. Their feedback loop is short, and each component from their factory is an improvement on the previous version. Sometimes they take shortcuts. Where NASA’s slogan is ‘failure is not an option,’ SpaceX goes with ‘Just send it.’ Learning happens in practice. Practice is more valuable than theory. Stability and reliability are achieved by doing something frequently and thus eliminating all errors. This is similar to DevOps: deploying and releasing software. The more you do it, the better and faster you become.</p> <p>SpaceX has gained experience with this approach by landing their Falcon 9 rocket. While the world said it was madness to land a returning rocket on Earth and relaunch it, SpaceX proved it could be done. The latest version of this rocket has landed successfully 225 times (out of 236 attempts). This rocket is the most reliable rocket ever made, and even the landing has a higher reliability than all other rockets in terms of launches. An impression of the first landing attempts is summarized in a hilarious YouTube video <a href="https://www.youtube.com/watch?v=bvim4rsNHkQ">‘How not to land an orbital class rocket booster.’</a></p> <h2 id="spacexs-innovation-algorithm">SpaceX’s Innovation Algorithm</h2> <p>SpaceX uses an innovation algorithm consisting of five principles. Every engineer at SpaceX works according to these five principles, which can also be applied in the DevOps world. The principles are:</p> <ul> <li>Make the requirements less dumb</li> <li>Delete the part or process step</li> <li>Optimize</li> <li>Accelerate</li> <li>Automate</li> </ul> <h3 id="make-the-requirements-less-dumb">Make the requirements less dumb</h3> <p>You must assume that the requirements you are told are always wrong. The question is, how wrong are they? You must question the requirements because continuous learning and new insights emerge. Primarily, it is about seeking the right question.</p> <p>Where people collaborate on a complex whole, constraints around the requirements arise. In English, we call them ‘constraints.’ As an engineer, you must adhere to the constraints when realizing a part within a complex whole. Otherwise, it won’t align with a component someone else has created. Many organizations believe this is efficient and effective. It gives you less freedom in realizing a certain component both in process and actual result. This results in what we call ‘local optimization.’ You build the best you can but within these constraints. This does not mean the whole system works optimally.</p> <p>At SpaceX, simply accepting a constraint as a constraint is out of the question. A constraint must always be challengeable because constraints increase the complexity of the whole. Experience shows that with constraints, often no one really knows why the constraint exists or was imposed by someone who has since left. You want to strive for ‘global optimization’ and want people to look beyond departments and individuals to jointly realize the best solution.</p> <p>During software development, engineers must always be able to challenge the requirements. In practice, this often happens with product owners. Something is conceived, but a product owner is also just a human with biases/beliefs. Already in 2009, Microsoft proved with this <a href="http://ai.stanford.edu/~ronnyk/ExPThinkWeek2009Public.pdf">paper</a> that 2/3 of all software developed has no or negative value. Impact mapping, feature mapping, and behavior-driven development can help in software development to ask the right questions, challenge the requirements, and uncover the right requirements. Data telemetry and observability can further support this by quickly learning from practice.</p> <h3 id="delete-the-part-or-process-step">Delete the part or process step</h3> <p>If the component or process step is not there at all, it saves time, money, and especially complexity.</p> <p>SpaceX wants to fully reuse Starship, so the rocket must be able to land. Creating a landing gear is complex and adds extra weight. Therefore, SpaceX has completely removed the landing gear from the rocket. The rocket is caught in mid-air by two large grab arms. Imagine a 70-meter-tall and 9-meter-diameter building being caught from the air. The complexity is moved to the launch &amp; landing tower, allowing the rocket to carry more cargo because the landing gear is no longer needed.</p> <p>Engineers often make the mistake of optimizing or automating something that shouldn’t exist at all. As an example, I want to mention Kubernetes. Kubernetes is a fantastic product with many great possibilities but can quickly become complex. If you don’t have scalability or availability problems for an application, why make it more complex? Kubernetes is extremely suitable for improving these quality aspects. If scalability and availability are not an issue for your application, don’t implement it and keep it simple. We engineers need a holistic view of the whole to oversee this. Good engineers are good at system thinking.</p> <h3 id="optimize">Optimize</h3> <p>The optimize step is essentially repeating the steps of “make the requirements less dumb” and “delete the part of the process step” several times. How often? That can’t be said. It is important to understand that our IT world is a complex whole. No one sees the whole picture, and complex systems are <a href="https://www.adaptivecapacitylabs.com/HowComplexSystemsFail.pdf">always on the verge of failure.</a> The simpler the whole, the fewer components are used, and the higher the reliability. This creates a conflict for many engineers because it’s often thought that the more tooling, the better. To make matters worse, complexity sells better, as <a href="https://www.cs.utexas.edu/users/EWD/transcriptions/EWD08xx/EWD896.html">Edsger Dijkstra</a> once said.</p> <p>Engineers often make the mistake of optimizing or automating something that shouldn’t exist in the first place. As an example, I would like to mention Kubernetes. Kubernetes is a fantastic product with many great features but can quickly become complex. If you don’t have scalability or availability issues for an application, why make the whole thing more complex? Kubernetes is ideally suited to improve precisely these quality aspects. If scalability and availability are not a problem for your application, don’t implement it and keep it simple. We engineers need a holistic view of the whole to oversee this. Good engineers are good at <a href="https://en.wikipedia.org/wiki/Systems_thinking">system thinking.</a></p> <h3 id="accelerate">Accelerate</h3> <p>After iterating through the whole and optimizing it several times, then go faster. By going faster, you remove errors from the process or product. You discover weaknesses or identify which elements need attention. By accelerating, you make new discoveries.</p> <p>This aligns with the saying “if it hurts, do it more often.” You can always go faster, but be careful not to go too fast, as this could create unacceptable risks, especially when there is potential for reputational, financial, or even life-and-death damage.</p> <p>I’ve experienced my team being under pressure to deliver several features by a certain date. To deliver faster, we decided to spend less time testing. We accepted the risk that our customers might encounter errors. The result? It was quite manageable; yes, there were some complaints, yes, we saw strange situations in the logs, but ultimately we resolved them quickly. We realized that we were structurally over-testing and that our test coverage could be reduced to deliver faster. This led to a revision of the measures we took as a team regarding risk mitigations.</p> <h3 id="automate">Automate</h3> <p>Only after performing the first four steps do you start automating. Automating helps you go even faster and standardize. You streamline the process further. You only automate last because that’s when you can efficiently and effectively automate the whole.</p> <h2 id="the-relationship-with-devops-way-of-working-and-the-pitfall-of-automate-everything">The Relationship with DevOps Way of Working and the Pitfall of ‘Automate Everything’</h2> <p>I often encounter teams that follow the “automate everything” principle. I think it’s not a good idea because starting with automation can increase inefficiency. Bill Gates said this years ago:</p> <blockquote> <p>“The first rule of any technology used in a business is that automation applied to an efficient operation will magnify the efficiency. The second is that automation applied to an inefficient operation will magnify the inefficiency.” - Bill Gates</p> </blockquote> <p>In our DevOps world, we engineers should more often reflect on the principles of SpaceX and be less quick to jump on the automation and tooling hype. It makes sense because most job openings don’t ask for optimization. They ask for tooling and thus automation knowledge.</p> <p>In my opinion, a good engineer has a holistic view of the whole, asks critical questions, and always looks at whether complexity can be reduced to create a more reliable and cheaper whole. Let’s look more at how SpaceX develops rockets. If they can do it with rockets, we should be able to do it with our software too.</p> <p>In which rocket would you like to take a trip around the moon? A rocket that has been thoroughly tested on paper and on the ground and has flown only a handful of times, or a rocket that initially exploded often and from which all weaknesses were removed through a fast learning process?</p>]]></content><author><name></name></author><category term="DevOps"/><summary type="html"><![CDATA[This post explains the awesome things that are happening right now at Starbase and what we as professionals can learn from SpaceX]]></summary></entry><entry><title type="html">Serious Gaming – Learn Specification by Example with the mBot</title><link href="https://foxhole.nl/blog/2016/spec-by-example-and-mbot/" rel="alternate" type="text/html" title="Serious Gaming – Learn Specification by Example with the mBot"/><published>2016-11-30T23:36:10+00:00</published><updated>2016-11-30T23:36:10+00:00</updated><id>https://foxhole.nl/blog/2016/spec-by-example-and-mbot</id><content type="html" xml:base="https://foxhole.nl/blog/2016/spec-by-example-and-mbot/"><![CDATA[<figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/mbot-480.webp 480w,/assets/img/mbot-800.webp 800w,/assets/img/mbot-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/mbot.jpg" class="img-fluid rounded z-depth-0" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <blockquote> <p>This blogpost was writen for Bartosz and originally posted in Dutch on <a href="https://www.bartosz.nl">the Bartosz website</a></p> </blockquote> <p>One of our colleagues discovered the mBot some time ago to teach his son how to program. It turns out that this mBot is not only interesting for children. This funny little robot is excellent for playfully mastering ‘Specification by Example.’</p> <h2 id="mbot">mBot</h2> <p>The mBot is a small robot that is highly customizable and equipped with various sensors and motors to drive the wheels. What makes the mBot unique is the combination of hardware and software. The hardware is based on the open-source hardware platform Arduino and can be expanded. With the Scratch application, you can visually program by dragging code blocks and creating a routine around the robot’s behavior. The customizability of the robot and the price, around 80 euros, make it an attractive package. The mBot project was originally intended for education to teach children programming. The manufacturer’s slogan is therefore ‘one robot per kid.’</p> <h2 id="specification-by-example">Specification by Example</h2> <p>We see that Specification by Example (SbE) or Behavior Driven Development (BDD) is increasingly adopted by agile teams. Traditionally, a lot of information is transferred during the specification, building, and testing of software. From business, to analysts, to developers, to testers, who then report results back to the business. This process at least does not contribute to clear specifications, code, and tests. Besides, have you ever caught yourself using examples to explain something, providing concrete handles and clarity to abstract concepts?</p> <p>That’s why we shape our specifications in examples. These examples can be seen as executable specifications that validate and verify requirements and give new meaning to test automation. By describing these examples in Gherkin syntax: ‘Given, When, Then,’ we can describe system behavior in a way that is clear to all involved.</p> <h2 id="the-combination-and-statement">The Combination and Statement</h2> <p>Soon, the idea arose within Bartosz to combine Specification by Example and playing with the mBot. A serious learning moment with lots of fun. The behavior of the mBot is central; based on the sensors, a status can be determined, and based on that status, the robot should exhibit certain behavior. Additionally, the robot is just a lot of fun to play with, it is tangible, and it reacts immediately.</p> <p>We also wanted to make a statement, namely the misconception that Specification by Example or Behavior Driven Development has something to do with testing or test automation. The shared vision, the discussions, the uniform language, and its tight scenarios naturally contribute to the quality of the application. However, we should not view the examples as tests but as specifications that drive the development of the application and thus become executable specifications. Nevertheless, the application can still contain errors or, with the speed of current software development, the just implemented feature can immediately provide new insights. We see facilitating this as the new role of the tester; learning, discovering, and exploring possibilities.</p> <h2 id="workshop-specification-by-example-with-robots">Workshop ‘Specification by Example with Robots’</h2> <p>For various clients and during the TestNet Summer Workshops, we organized the workshop ‘Specification by Example with Robots.’ In this workshop, you learn to model the behavior of a robot using Specification by Example. With these examples in hand, you program the robot with the goal of completing a course without errors in the shortest possible time!</p> <p>The workshop begins with a theoretical introduction to Specification by Example and more insight into what the mBot is and can do. Then the practical part begins. We set up a course with a zigzag line, a right-angled turn to the right, a right-angled turn to the left, with walls and a garage where the mBot must come to a stop. The mBot has sensors that should follow the line, but you cannot blindly rely on them. The behavior to be exhibited at the wall and garage are different patterns. The ultimate goal is to program the robot to navigate the course flawlessly in the shortest time! But we only start implementing the code once we have a shared vision of what needs to be implemented. In groups of 4 to 5 people, the examples are worked out. The groups usually quickly conclude that mentioning sensor data in the scenarios is not the intention. It’s about business value and describing the desired behavior of the robot. Intensive collaboration ensues to use a common language within the team, which is the intention of Specification by Example or Behavior Driven Development. These increase synergy within the team and involvement with the business. Thus, the right product can be built in one go.</p> <p>After thinking through the scenarios, we proceed with implementing the Scratch code based on the examples, to then combine everything into one whole. This is where the big ‘fun factor’ of this workshop begins. We’ve seen quite a few robots perform the craziest capers.</p> <p>We look back with pleasure at the Specification by Example with Robots workshops organized so far. Clients experience the workshop as very educational and have a fun afternoon together.</p> <h2 id="the-next-steps">The Next Steps</h2> <p>Of course, at Bartosz, we are not sitting still. After the success at TestNet, we decided to further expand the workshop. The next version of the workshop will be more realistic with what we, as test consultants, do on our assignments: Executable specifications are created from the examples via Cucumber and Java. Consciously or unconsciously, participants will learn concepts such as Dependency Injection and Mocking and the fact that you can leave out the mBot while programming the behavior. Not just specifications but true outside-in development and a proper setup of the test automation pyramid.</p>]]></content><author><name></name></author><category term="Testing"/><category term="BDD"/><category term="SbE"/><summary type="html"><![CDATA[This is a little story about my journey as a tester]]></summary></entry><entry><title type="html">10 years of testing - from covering your ass to accelerating feedbackloops</title><link href="https://foxhole.nl/blog/2016/10-years-of-testing/" rel="alternate" type="text/html" title="10 years of testing - from covering your ass to accelerating feedbackloops"/><published>2016-01-10T23:36:10+00:00</published><updated>2016-01-10T23:36:10+00:00</updated><id>https://foxhole.nl/blog/2016/10-years-of-testing</id><content type="html" xml:base="https://foxhole.nl/blog/2016/10-years-of-testing/"><![CDATA[<figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/revolution-480.webp 480w,/assets/img/revolution-800.webp 800w,/assets/img/revolution-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/revolution.jpg" class="img-fluid rounded z-depth-0" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <p>10 years ago, I started as a tester. During my higher vocational education, I heard an advertisement on the radio about a company called Getronics that was looking for recent graduates to train them in the field of testing. I was hired and, together with nine other young, newly graduated computer science students, I attended the testing masterclass where we were drilled in the theory of TMap, critical thinking, and what it means to work as a tester. My first assignments were silo-oriented. Large test teams of more than 10 people. The developers were housed on a different floor, and communication was mainly done through a defect tracking system. I remember we registered the 10,000th defect for an application. Sausage rolls for the testers, plus champagne, as it turned out the defect tracking system couldn’t handle more than 9999 defects. As a tester, you took pride in finding errors or providing a quality recommendation by counting test cases, whatever such a quality or release recommendation might be. Writing test plans, which were mostly to cover yourself, setting boundary conditions, and especially formulating clear entry and exit criteria so everyone knew where they stood. Because of the V-model.</p> <p>RUP (Rational Unified Process) made its appearance. Massively adjusting templates, massively creating artifacts. I think I still have a RUP certificate somewhere. You also saw testers developing certain expertise: Web tester, SAP tester, SOA tester, and later Cloud tester, which made you quite special. Test tooling and test automation became increasingly important, or at least, more experimented with. We did test automation, but was it successful? There was little to no alignment with developers, record &amp; playback tools that supposedly could do everything and made everything easier. The manufacturers promised the moon, and the tools themselves cost a fortune. Cool, an automated test set that ran for 25 hours, if it even worked with flaky or brittle tests because there was a great dependency on the test infrastructure and test data.</p> <p>Agile came, no, really Agile didn’t come, Scrum came, and with it, we thought we were being Agile. All over the country, silos were transformed into scrum teams. A good development because suddenly you were really sitting next to the analyst or developer. You picked up things about other disciplines, and as a tester, you had a more direct influence on designs, for example. Today, every tester is an agile tester, agile test coordinator, or even agile test manager. I don’t understand the last two, and I still struggle with the first one. What exactly is an agile tester? A tester who is in a scrum team? What makes a tester truly agile? I deliberately poke fun at it because I still see so many (agile) testers around me who pick up their TMap book and distill test cases from the test basis – formed by a ready team before the sprint starts – and thereby do bi-weekly waterfalls. We really struggle to deliver a potentially shippable increment because many organizations and scrum teams are not yet ready for it. Why is that? Because I think we still do not collaborate enough and are not multidisciplinary enough. Additionally, having an ISTQB and/or TMap certificate is a requirement for almost all testing vacancies, both permanent and contract. This while there is far too little attention to Exploratory Testing in these two methodologies.</p> <p>Test automation has become so important that we have a shortage of test automators. Everything revolves around Selenium, and companies are emerging that focus on technical testing and only provide test automators. In marketing, we call it ‘automated testing.’ By the way, I’m looking for someone who can explain to me what automated testing is. Haven’t we all created a skewed testing world? Testers who can’t automate and automators who can’t test? Why do we make such a big distinction between the tester and the test automator?</p> <p>Now, 10 years later, two owner-occupied houses later, two employers later, now married, and regularly finding a gray hair in my sideburns (by the way, no relation between the last two), I wonder if the changes we see now in the testing field are an evolution or a revolution. As I outlined above, the evolution has always been there in terms of technology and development methodologies. Testing, itself not a trendsetter, has always neatly followed the trends in the market.</p> <p>Now I really see the testing world changing. For eight years, I could easily keep up with the knowledge I gained during my testing masterclass. The nature of testing tasks slowly changed with the market. But now, now there’s something peculiar happening in the market. Developers are becoming increasingly aware of quality, testing their delivered software better and better, and the speed at which Continuous Delivery and DevOps deliver software is phenomenal. It is the path to truly being Agile, and as a tester, you can no longer get by with your test cases, defect registration, and a heap of automated end-to-end tests via Selenium. At the end of the sprint, that potential shippable increment is really a requirement. Scripted testing is being replaced by examples we create through ATDD/BDD/SbE. Exploratory Testing is also a must, but unfortunately, there are not many testers who are really good at it. I can therefore recommend the Rapid Software Testing training to everyone. Great training! Everyone starts testing, even the developer who has followed this RST training and sets up an ET charter. Test automation? We no longer do that separately. ATDD/TDD are so embedded in the way of working that we get a proper implementation of the test automation pyramid. And we now call it check automation. And who realizes those automated checks with outside-in-development? The developers and no longer the test automators. How cool is that?! We get well-maintainable test automation code that is considered just as important as the production code. The end of the test automator?</p> <p>Quality has never been so important because errors can cause great damage to the reputation of companies. This is more relevant now than ever, competition is greater than ever, and the time to market needs to be shorter than ever. The necessity of testing has also never been so great. The tester as we know it now will disappear, at least in environments moving towards Continuous Delivery and DevOps. A new role will emerge, call it the feedback engineer. This engineer will continuously collect feedback on whether the right product has been built, whether this product can add value at all. Whether the product is built in the right way, at the right time, and will also establish through monitoring whether it actually adds value in production. I really see this as a very different interpretation of the testing field than the previous changes. As far as I’m concerned, it’s a revolution, and not everyone agrees with that, let alone is happy with it.</p> <p>The strange thing is that it seems as if this revolution is not or hardly supported by the real testing companies or test business units at companies, both of which provide large numbers of testers through secondment. The revolution is mainly driven by software development parties. Are the testing companies sleeping too much or holding on too much to the old ways? Or am I diluting my own field by – at least it seems – looking at it differently? Will there still be work in a few years for the average tester and/or test automator? These are just a few questions that occupy me, and I am happy and enthusiastic to talk with you about them.</p> <p>What I can tell you is that my learning curve over the past ten years has never been as steep as it is now, and that my passion and enjoyment in the field have never been as great. I enjoy the comments from developers who are happy with the CI build that provides feedback within 10 minutes on whether their refactor hasn’t accidentally broken something. I enjoy facilitating, making sure developers can develop faster. I enjoy really learning to program with mock objects instead of scripting. I enjoy working out examples with an analyst and developer during a three amigos session, and I enjoy setting up the CD pipeline. I enjoy the coaching I give to, yes, make myself redundant.</p> <p>But above all, I enjoy the fact that the quality of the software we deliver is getting better and better. Without a pre-written test plan of 30+ pages or a poorly set-up defect registration system. Collaboration, pair-programming, mind maps &amp; diagrams on the wall, and a lot of feedback back and forth, on all fronts, and enormous coverage with fast automated checks. I recommend you embark on the adventure, it’s so much more fun!</p>]]></content><author><name></name></author><category term="Testing"/><summary type="html"><![CDATA[This is a little story about my journey as a tester]]></summary></entry></feed>